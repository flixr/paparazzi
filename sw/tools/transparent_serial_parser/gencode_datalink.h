% Copyright (C) 2010 Eric Parsonage
%
% file    : gencode.m
% purpose : generates a header file of functions that output paparazzi
%           format messages in human readable form. It does this by
%           parsing messages.xml
%
% This is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2, or (at your option)
% any later version.
%
% it is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with this code; see the file COPYING.  If not, write to
% the Free Software Foundation, 59 Temple Place - Suite 330,
% Boston, MA 02111-1307, USA.



% some messages are beyond the scope of this parsers ability since they
% contain variable length array the caller prints the paylod in hex
% and the generated handler merely prints a string describing the message
%difficult_messages = [2 26 52 90 100 101 102 104 105 111 183 184 186 211]; %messages section

difficult_messages = [6 12 13 97] % datalink section

% the file containing the generated message handlers
fid = fopen('handlers.h','w');
% write a copyright notice to the generated file
fprintf(fid, '/* %s */\n','Copyright (C) 2010 Eric Parsonage');
fprintf(fid, '/* %s */\n','Automatically Generated by gencode.m');
fprintf(fid, '/* %s */\n',['Purpose: a collection of functions that',...
                         ' output paparazzi messages in human',...
                         ' readable form']);


% setup some structures to be used to create an array of function
% pointers in the c header file we are about to create
ids = [0:255]
names = cell(1,256);

for i = 1:256
    names{1,i} = 'HANDLER_DEFAULT';
end;


% read in the xml definition file
xDoc = xmlread('messages.xml');
class_nodes = xDoc.getElementsByTagName('class')

% find the telemetry class we are only interested in the messages
% defined in this class
for k = 0:class_nodes.getLength-1
   messageNode = class_nodes.item(k);
   attributes = [];
    if messageNode.hasAttributes
       theAttributes = messageNode.getAttributes;
       numAttributes = theAttributes.getLength;
       for count = 1:numAttributes
          attrib = theAttributes.item(count-1);
          if strcmpi('name',char(attrib.getName))
              % if strcmpi('telemetry', char(attrib.getValue))
              if strcmpi('datalink', char(attrib.getValue))
                  telemetry_node = messageNode;
                  break;
              end
          end
       end
    end
end


% we have the telemetry class now iterate through its children
% which are messages writing out handlers for each type of message in
% c code to a file as we go
allListItems = telemetry_node.getElementsByTagName('message'); % messages section


for k = 0:allListItems.getLength-1
    messageNode = allListItems.item(k);
    if messageNode.hasAttributes
        theAttributes = messageNode.getAttributes;
        numAttributes = theAttributes.getLength;
        for count = 1:numAttributes
            attrib = theAttributes.item(count-1);
            if strcmpi('name',char(attrib.getName))
                message_name = char(attrib.getValue)
            end
            if strcmpi('id',char(attrib.getName))
                message_id = str2num(attrib.getValue)
            end
        end
        % so now we have the message id and its name
        % store them in ids and names so they can be used
        % to create an array of function pointers in
        % the c header file that we output
        ids(1,message_id + 1) = message_id;
        func_name = strcat('HANDLER_', message_name);
        names{1,message_id + 1} = func_name;

        % write out a function header for this handler

        fprintf(fid, '%s\n',...
            ['void ', func_name, ...
            '(unsigned char * data, unsigned char len)']);
        fprintf(fid, '%s\n',...
            ['{']);

        fieldNodes = messageNode.getElementsByTagName('field');
        numFieldNodes = fieldNodes.getLength;

        % if we have fields to parse then we need to keep track of
        % the offset into the byte stream for each field the c
        % parser will store this in the variable offset for each
        % handler
        if numFieldNodes > 0
            fprintf(fid, '%s\n',[ '  unsigned char offset = 0;']);
        end

        % each handler prints out the name of the message first
        % write out the c code to do this
        fprintf(fid, '%s\n',...
            ['  printf("MESSAGE = %s\n", "', message_name, '");']);

        % we have a list of messages that are difficult to parse because
        % they have variable length. We dont handle them here it will be
        % necessary to extend this code to handle them or to hand code
        % handlers for these messsages.
        if length(find(difficult_messages == message_id)) > 0
            fprintf(fid, '%s\n',...
                ['/* this message contains a variable length array */']);
        else
            % if a message contains data fields
            if messageNode.hasChildNodes

                % for each data field in the message
                for field_num = 0:numFieldNodes-1
                    theField = fieldNodes.item(field_num);

                    % find the name and type of field its units,
                    % alternate units and alternate unit coefficient.
                    if theField.hasAttributes
                        theAttributes = theField.getAttributes;
                        numAttributes = theAttributes.getLength;
                        field_units = '';
                        field_alt_units = '';
                        field_alt_unit_coef = 0;
                        for count = 1:numAttributes
                            attrib = theAttributes.item(count-1);

                            if strcmpi('name',char(attrib.getName))
                                field_name = char(attrib.getValue);
                            end

                            if strcmpi('type',char(attrib.getName))
                                field_type = char(attrib.getValue);
                            end

                            if strcmpi('unit',char(attrib.getName))
                                field_units = char(attrib.getValue);
                            end

                            if strcmpi('alt_unit',char(attrib.getName))
                                field_alt_units = char(attrib.getValue);
                            end

                            if strcmpi('alt_unit_coef',...
                                    char(attrib.getName))
                                field_alt_unit_coef =...
                                    str2num(char(attrib.getValue));
                            end
                            % could handle more of the attributes here
                        end
                    end

                    % work out c types on PC and format specifiers
                    if strcmpi(field_type, 'float')
                        format = '%f';
                    end;

                    if strcmpi(field_type, 'double')
                        format = '%lf';
                    end;

                    if strcmpi(field_type, 'uint8')
                        format = '%u';
                        field_type = 'unsigned char';
                    end;

                    if strcmpi(field_type, 'uint16')
                        format = '%u';
                        field_type = 'unsigned short';
                    end;

                    if strcmpi(field_type, 'uint32')
                        format = '%u';
                        field_type = 'unsigned int';
                    end;


                    if strcmpi(field_type, 'int8')
                        format = '%d';
                        field_type = 'char';
                    end;

                    if strcmpi(field_type, 'int16')
                        format = '%d';
                        field_type = 'short';
                    end;

                    if strcmpi(field_type, 'int32')
                        format = '%d';
                        field_type = 'int';
                    end;

                    % this is where we write the code to the C file of
                    % message handlers for handling a field we start a new
                    % block of code to allow use to define a new temporary
                    % variable for each field whithout having to generate
                    % unique variable names.
                    fprintf(fid, '%s\n',...
                        ['  {']);

                    % write out c code to define the temporary variable
                    fprintf(fid, '%s\n',...
                        ['     ', field_type,' tmp;']);

                    % write out c code to copy the field from the byte
                    % stream to our temporary variable
                    fprintf(fid, '%s\n',...
                        ['     memcpy(&tmp, data + offset, sizeof(',...
                        field_type,'));']);

                    % write out c code to increment the variable that
                    % stores the current offset into the bytestream
                    fprintf(fid, '%s\n',...
                        ['     offset += sizeof(',field_type,');']);

                    % if we have alternate units we want the C code to
                    % display them
                    if (field_alt_unit_coef > 0.0)
                        % we may have alternate units but not primary units
                        % we generate code to have a slightly different
                        % way of displaying them
                        if (length(field_units) > 0)
                            fprintf(fid, '%s\n',...
                                ['     printf("', field_name,' = (',...
                                format,' ',field_units, ') %lf ',...
                                field_alt_units,...
                                '\n", tmp,(double)(tmp*',...
                                num2str(field_alt_unit_coef),'));']);
                        else
                            fprintf(fid, '%s\n',...
                                ['     printf("', field_name,' = (',...
                                format,') %lf ',...
                                field_alt_units,...
                                '\n", tmp,(double)(tmp*',...
                                num2str(field_alt_unit_coef),'));']);
                        end

                    else
                        % generate code to print the value if we dont have
                        % any alternate units available.
                        fprintf(fid, '%s\n',...
                        ['     printf("', field_name,' = ',...
                        format,' ',field_units, '\n", tmp);']);
                    end
                    % generate c code to finish of this block of code
                    fprintf(fid, '%s\n',...
                        ['  }']);

                end
            end
        end
        % generate c code to finish of the current message handler function
        fprintf(fid, '%s\n\n','}');
    end
end

% output an array of function pointers to the message handlers created
% above
fprintf(fid,'%s\n',...
    'typedef void (*ptrHandler)(unsigned char *, unsigned char len);');

fprintf(fid,'%s\n',...
    'ptrHandler funcArray[256] = {');

for i = 1:255
    fprintf(fid,'%s\n',[names{1,i}, ',']);
end

fprintf(fid,'%s\n',names{1,256});
fprintf(fid, '%s\n\n','};')
